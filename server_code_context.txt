// File: server/api/geminiApi.js
import { GoogleGenerativeAI } from "@google/generative-ai";
import dotenv from "dotenv";

dotenv.config();

const GEMINI_API_KEY = process.env.GEMINI_API_KEY;

const genAI = new GoogleGenerativeAI(GEMINI_API_KEY);

export async function fetchGeminiData(query) {
  try {
    const model = genAI.getGenerativeModel({ model: "gemini-pro" });
    const result = await model.generateContent(query);
    const response = await result.response;
    return response.text();
  } catch (error) {
    console.error('Error fetching data from Gemini API:', error);
    throw new Error('Failed to process your request with Gemini AI. Please try again.');
  }
}

// File: server/config/googleCloud.js
import dotenv from "dotenv";
import { Storage } from '@google-cloud/storage';

dotenv.config();

const storage = new Storage ({
  keyFilename: process.env.GOOGLE_CLOUD_CREDENTIALS,
});

export default storage;
// File: server/config/pinecone.js
import fetch from "node-fetch";
globalThis.fetch = fetch;

import { Pinecone } from "@pinecone-database/pinecone";

const pc = new Pinecone({
  apiKey: process.env.PINECONE_API_KEY
});

export default pc;
// File: server/db/professorDataStore.js
import { addProfessorToPinecone } from '../service/pineconeService.js';
import { scrapeProfessorData } from '../service/scraper.js';

// Function to scrape Professor's page and store in Pinecone
export async function processProfessorPage(url) {
  try {
    // Scrape the professor data from the given url
    const professorData = await scrapeProfessorData(url);

    // Check if the scraped data is valid
    if (!professorData || !professorData.name || professorData.reviews.length === 0) {
      console.warn(`Scraping from ${url} returned insufficient data. Skipping storage.`);
      return { success: false, message: "Invalid or insufficient professor data" };
    }

    // Format data to be stored in Pinecone
    const formattedData = {
      id: `prof_${Date.now()}`, //Create a unique ID for the professor
      name: professorData.name,
      // department: professorData.department,
      rating: parseFloat(professorData.rating), // Converting rating to a float if necessary
      review: professorData.reviews.join(' ') // Combine all reviews into a string
    };

    // Store the formatted data in Pinecone
    await addProfessorToPinecone(formattedData);
    console.log(`Successfully added ${professorData.name} to Pinecone!`);

    return { success: true, message: "Professor data scraped and stored successfully", data: formattedData };
  } catch (error) {
    console.error('Error processing professor page:', error);
    throw error;
  }
}
// File: server/firebase.js
// Import the functions you need from the SDKs you need
import { initializeApp } from "firebase/app";
import { getAnalytics } from "firebase/analytics";
import { getFirestore } from "firebase/firestore";
// TODO: Add SDKs for Firebase products that you want to use
// https://firebase.google.com/docs/web/setup#available-libraries

// Your web app's Firebase configuration
// For Firebase JS SDK v7.20.0 and later, measurementId is optional
const firebaseConfig = {
  apiKey: "AIzaSyBNXJ4vKb5zr79C7NKHrhghkNYM9uZ7XdY",
  authDomain: "professor-rating-a175c.firebaseapp.com",
  projectId: "professor-rating-a175c",
  storageBucket: "professor-rating-a175c.appspot.com",
  messagingSenderId: "931391666593",
  appId: "1:931391666593:web:44f2e3d53f68c0369db3e0",
  measurementId: "G-37E97N9DW5"
};

// Initialize Firebase
const app = initializeApp(firebaseConfig);
let analytics;
if (typeof window !== 'undefined') {
  analytics = getAnalytics(app);
}
const db = getFirestore(app);

export { db };
// File: server/index.js
import express from 'express';
import dotenv from 'dotenv';
import cors from 'cors';
import fetch from 'node-fetch';
import chatRoutes from './routes/chat.js';
import professorRoutes from './routes/professor.js';
import scrapingRoutes from './routes/scraping.js';
import './config/pinecone.js';
import './config/googleCloud.js';

global.fetch = fetch;

dotenv.config();

const app = express();
const port = process.env.PORT || 3000;

app.use(cors());
app.use(express.json());
app.use('/', chatRoutes);
app.use('/', professorRoutes);
app.use('/', scrapingRoutes);

app.listen(port, () => {
  console.log(`Professor rating app listening at http://localhost:${port}`);
});
// File: server/routes/chat.js
import express from "express";
import { fetchGeminiData } from "../api/geminiApi.js";
import { queryPineconeForProfessor } from "../service/pineconeService.js";
import { db } from "../firebase.js";
import { collection, addDoc, getDocs, query, where } from "firebase/firestore";

const router = express.Router();

router.post("/api/chat", async (req, res) => {
  const userMessage = req.body.message;
  const userId = req.body.userId;

  // Helper function moved inside the router.post callback
  function isGreetingOrGeneralQuestion(message) {
    const greetings = [
      "hi",
      "hello",
      "hey",
      "greetings",
      "good morning",
      "good afternoon",
      "good evening",
    ];
    return (
      greetings.some((greeting) => message.toLowerCase().includes(greeting)) ||
      message.toLowerCase().includes("how are you")
    );
  }

  try {
    let response;
    let replyType = "general";

    // Check if it's a greeting or general question
    if (isGreetingOrGeneralQuestion(userMessage)) {
      response = await fetchGeminiData(
        `Respond to this message: ${userMessage}`
      );
    } else {
      const refinedQuery = await fetchGeminiData(
        `Refine this search query for professor recommendations: ${userMessage}`
      );
      console.log("Refined Query:", refinedQuery);

      const professorRecommendations = await queryPineconeForProfessor(
        refinedQuery
      );
      console.log("Pinecone Recommendations:", professorRecommendations);

      const personalizedRecommendations = await fetchGeminiData(`
        Generate personalized professor recommendations based on these results:
        ${JSON.stringify(professorRecommendations)}
        
        Format the response as a valid JSON array of objects, each containing:
        - name: professor's name
        - department: professor's department (use "N/A" if not available)
        - rating: professor's rating (as a number)
        - recommendation: a brief personalized recommendation
        
        Ensure the response is a properly formatted JSON string without any additional text before or after the JSON data.
        The response should contain exactly 5 professor recommendations.
        Do not use markdown formatting in your response.
      `);

      console.log("Raw Gemini Response:", personalizedRecommendations);

      let formattedRecommendations;
      try {
        const cleanedResponse = personalizedRecommendations
          .replace(/```json\n|\n```/g, "")
          .trim();
        formattedRecommendations = JSON.parse(cleanedResponse);
      } catch (parseError) {
        console.error("JSON Parse Error:", parseError);
        console.error("Problematic JSON string:", personalizedRecommendations);
        throw new Error(
          "We're having trouble processing the recommendations. Please try your request again."
        );
      }

      if (
        !Array.isArray(formattedRecommendations) ||
        formattedRecommendations.length !== 5
      ) {
        throw new Error(
          "We couldn't generate the expected number of recommendations. Please try your request again."
        );
      }

      // Validate each recommendation object
      formattedRecommendations.forEach((rec, index) => {
        if (!rec.name || rec.rating === undefined || !rec.recommendation) {
          throw new Error(
            `We're missing some information for one of the recommendations. Please try your request again.`
          );
        }
        rec.department = rec.department || "N/A";
        if (typeof rec.rating !== "number") {
          rec.rating = parseFloat(rec.rating);
          if (isNaN(rec.rating)) {
            throw new Error(
              `We encountered an issue with a professor's rating. Please try your request again.`
            );
          }
        }
      });

      response = formattedRecommendations.map((rec) => ({
        ...rec,
        type: "recommendation",
      }));
      replyType = "recommendation";
    }

    // Store chat history in Firestore
    if (userId) {
      await addDoc(collection(db, "chatHistory"), {
        userId,
        userMessage,
        response,
        replyType,
        timestamp: new Date(),
      });
    } else {
      console.warn("Chat history not saved: userId is undefined");
    }

    res.json({ reply: response });
  } catch (error) {
    console.error("Error processing chat request:", error);
    res.status(500).json({
      reply: [
        {
          text: "I'm sorry, but I couldn't process your request at this time. Please try again or rephrase your question.",
          type: "error",
        },
      ],
    });
  } finally {
    console.log("Chat request processing completed");
  }
});

// Route to retrieve chat history
router.get("/api/chat/history", async (req, res) => {
  const userId = req.query.userId;

  try {
    const q = query(
      collection(db, "chatHistory"),
      where("userId", "==", userId)
    );
    const querySnapshot = await getDocs(q);
    const chatHistory = querySnapshot.docs.map((doc) => doc.data());

    return res.json({ chatHistory });
  } catch (error) {
    console.error("Error retrieving chat history:", error);
    res
      .status(500)
      .json({ error: "Failed to retrieve chat history. Please try again." });
  }
});

export default router;

// File: server/routes/professor.js
import express from 'express';
import { addProfessorToPinecone } from '../service/pineconeService.js';
import { querySentimentTrends } from '../service/pineconeService.js';

const router = express.Router();

router.post('/api/add-professor', async (req, res) => {
  try {
    const professorData = req.body;
    console.log('Received professor data:', professorData);

    if (Array.isArray(professorData)) {
      for (const professor of professorData) {
        await addProfessorToPinecone(professor);
      }
    } else {
      await addProfessorToPinecone(professorData);
    }

    res.json({ success: 'Professor data added to Pinecone successfully.' });
  } catch (error) {
    console.error('Error in /api/add-professor route:', error);
    res.status(500).json({ error: 'Failed to add professor to Pinecone', details: error.message });
  }
});

router.get('/api/sentiment-trends/:professorName', async (req, res) => {
  const { professorName } = req.params;

  try {
    // Query Pinecone for sentiment trends for the given professor
    const trendData = await querySentimentTrends(professorName);
    res.status(200).json({ trends: trendData });
  } catch (error) {
    res.status(500).json({ error: 'Failed to retrieve sentiment trends.', details: error.message });
  }
});

export default router;

// File: server/routes/scraping.js
import express from "express";
import { scrapeProfessorData } from "../service/scraper.js";

const router = express.Router();

router.post("/api/scrape", async (req, res) => {
  try {
    const { url } = req.body;

    if (!url) {
      return res.status(400).json({ error: "URL is required" });
    }

    const result = await scrapeProfessorData(url);

    res.status(200).json({
      message: "Professor data scraped and stored successfully",
      data: result,
    });
  } catch (error) {
    console.error("Scraping error:", error);

    if (error.name === "ValidationError") {
      return res.status(400).json({ error: "Invalid data format" });
    }

    if (error.name === "ScrapingError") {
      return res
        .status(422)
        .json({ error: "Unable to scrape data from the provided URL" });
    }

    if (error.name === "StorageError") {
      return res.status(500).json({ error: "Failed to store scraped data" });
    }

    res.status(500).json({ error: "An unexpected error occurred" });
  }
});

export default router;

// File: server/service/embeddingService.js
import { pipeline } from '@xenova/transformers';

let model = null;

async function getEmbedding(text) {
  if (!model) {
    model = await pipeline('feature-extraction', 'Xenova/all-MiniLM-L6-v2');
  }
  const result = await model(text, { pooling: 'mean', normalize: true });
  return Array.from(result.data);
}

export { getEmbedding };

// File: server/service/pineconeService.js
import pc from "../config/pinecone.js";
import { getEmbedding } from "./embeddingService.js";
import { analyzeSentiment } from "./sentimentService.js";

// Function to add Professor data to Pinecone
export async function addProfessorToPinecone(professorData) {
  try {
    // Initialize Pinecone index
    const index = pc.Index("rag");

    // Check if reviewText exists and is not empty
    if (!professorData.review || professorData.review.trim() === "") {
      throw new Error("Review text is missing or empty");
    }

    // Generate embeddings for professor review text
    const vector = await getEmbedding(professorData.review);

    // Performs sentiment analysis on the review text
    const sentiment = await analyzeSentiment(professorData.review);

    // Prepare data to be stored in Pinecone
    const pineconeData = {
      id: professorData.name.replace(/\s+/g, "-").toLowerCase(),
      values: vector,
      metadata: {
        name: professorData.name,
        department: professorData.department,
        rating: professorData.rating,
        review: professorData.review,
        sentiment: await analyzeSentiment(professorData.review), // Store sentiment (e.g., 'positive', 'neutral', 'negative')
        timestamp: new Date().toISOString, // Store the current timestamp for trend tracking
      },
    };
    // Upsert (add or update) the data to Pinecone
    await index.upsert([pineconeData]);
    console.log("Professor data added to Pinecone successfully.");
  } catch (error) {
    console.error("Error adding professor to Pinecone:", error);
    throw error;
  }
}

export async function queryPineconeForProfessor(userQuery) {
  try {
    // Initialize Pinecone index
    const index = pc.Index("rag");

    // Generate embeddings for user query
    const queryVector = await getEmbedding(userQuery);

    // Query Pinecone for similar professor data
    const queryResponse = await index.query({
      vector: queryVector,
      topK: 20,
      includeMetadata: true,
    });

    // Extract the results and return them
    const results = queryResponse.matches.map((match) => ({
      name: match.metadata.name,
      department: match.metadata.department,
      rating: match.metadata.rating,
      similarity: match.score, // Similarity score from Pinecone
    }));
    return results;
  } catch (error) {
    console.error("Error querying Pinecone:", error);
    throw new Error(
      "Failed to retrieve data from Pinecone. Please try again later."
    );
  }
}

export async function querySentimentTrends(professorName) {
  try {
    // Initialize Pinecone index
    const index = pc.Index("rag");

    const dummyVector = Array(384).fill(0);

    // Query Pinecone for professor data by name, sorted by timestamp
    const queryResponse = await index.query({
      vector: dummyVector,
      filter: {
        name: { $eq: professorName }
      },
      topK: 20,
      includeMetadata: true,
    });

    // Extract sentiment data and timestamps
    const trends = queryResponse.matches.map((match) => ({
      sentiment: match.metadata.sentiment,
      rating: match.metadata.rating,
      timestamp: match.metadata.timestamp,
    }));

    // Sort by timestamp to show trends over time
    trends.sort((a, b) => new Date(a.timestamp) - new Date(b.timestamp));

    return trends;
  } catch (error) {
    console.error("Error querying sentiment trends:", error);
    throw new Error(
      "Failed to retrieve sentiment trends. Please try again later."
    );
  }
}

// File: server/service/scraper.js
import puppeteer from "puppeteer";

export async function scrapeProfessorData(url) {
  let browser;
  try {
    browser = await puppeteer.launch({
      headless: "new",
      args: ['--no-sandbox', '--disable-setuid-sandbox']
    });
    const page = await browser.newPage();
    await page.setDefaultNavigationTimeout(60000); // Increase timeout to 60 seconds

    await page.goto(url, { waitUntil: 'networkidle0' });

    const professorData = await page.evaluate(() => {
      // Helper function to find text by keywords
      const findTextByKeywords = (keywords) => {
        for (const keyword of keywords) {
          const element = document.evaluate(
            `//*[contains(translate(text(), 'ABCDEFGHIJKLMNOPQRSTUVWXYZ', 'abcdefghijklmnopqrstuvwxyz'), '${keyword.toLowerCase()}')]`,
            document,
            null,
            XPathResult.FIRST_ORDERED_NODE_TYPE,
            null
          ).singleNodeValue;
          if (element) {
            return element.innerText.trim();
          }
        }
        return null;
      };

      // Find the professor's name
      const nameKeywords = ['professor', 'dr.', 'prof.', 'name:'];
      const name = findTextByKeywords(nameKeywords) || document.querySelector('h1')?.innerText?.trim() || 'Unknown Professor';

      // Find department
      const departmentKeywords = ['department', 'dept.', 'subject', 'faculty', 'school of'];
      const department = findTextByKeywords(departmentKeywords);

      const ratings = document.querySelector('.ratings')?.innerText;
      const reviews = Array.from(document.querySelectorAll('.review')).map(review => review.innerText);

      return { name, department, ratings, reviews };
    });

    if (professorData.name === 'Unknown Professor' && !professorData.department) {
      throw new Error('Unable to scrape professor data');
    }

    return professorData;
  } catch (error) {
    console.error("Scraping error:", error);
    throw { name: 'ScrapingError', message: error.message, url };
  } finally {
    if (browser) {
      await browser.close();
    }
  }
}

// File: server/service/sentimentService.js
import { pipeline } from '@xenova/transformers';

let sentimentModel = null;

export async function analyzeSentiment(text) {
  if (!sentimentModel) {
    sentimentModel = await pipeline('sentiment-analysis', 'Xenova/distilbert-base-uncased-finetuned-sst-2-english');
  }

  const result = await sentimentModel(text);
  return result[0].label.toLowerCase();  // Returns 'positive', 'negative', or 'neutral'
}

